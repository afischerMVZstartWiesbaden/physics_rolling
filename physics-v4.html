<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Todo Bälle v4</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=Syne+Mono&display=swap');

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  overflow: hidden;
  font-family: 'Syne', sans-serif;
  height: 100vh; width: 100vw;
  transition: background 0.35s;
}

/* ── CSS Variables — Dark (default) ─────────────────────── */
:root {
  --bg:           #111118;
  --text:         rgba(255,255,255,0.75);
  --text-dim:     rgba(255,255,255,0.22);
  --text-label:   rgba(255,255,255,0.15);
  --border:       rgba(255,255,255,0.08);
  --panel-bg:     rgba(8,8,14,0.90);
  --input-bg:     rgba(255,255,255,0.06);
  --input-border: rgba(255,255,255,0.14);
  --btn-bg:       rgba(255,255,255,0.07);
  --btn-border:   rgba(255,255,255,0.14);
  --btn-text:     rgba(255,255,255,0.55);
  --tab-act-bg:   rgba(255,255,255,0.11);
  --tab-act-text: rgba(255,255,255,0.90);
  --zone-check:   rgba(70,210,120,0.6);
  --zone-glow:    rgba(70,210,120,0.3);
}

body.beige {
  --bg:           #ede8dc;
  --text:         rgba(8,5,3,0.88);
  --text-dim:     rgba(8,5,3,0.40);
  --text-label:   rgba(8,5,3,0.28);
  --border:       rgba(8,5,3,0.16);
  --panel-bg:     rgba(228,222,210,0.96);
  --input-bg:     rgba(8,5,3,0.05);
  --input-border: rgba(8,5,3,0.22);
  --btn-bg:       rgba(8,5,3,0.07);
  --btn-border:   rgba(8,5,3,0.22);
  --btn-text:     rgba(8,5,3,0.65);
  --tab-act-bg:   rgba(8,5,3,0.12);
  --tab-act-text: rgba(8,5,3,0.92);
  --zone-check:   rgba(20,100,55,0.70);
  --zone-glow:    rgba(20,100,55,0.28);
}

/* ── Canvas ─────────────────────────────────────────────── */
#c {
  display: block; position: fixed;
  top: 0; left: 0; z-index: 1;
}

/* ── Header ─────────────────────────────────────────────── */
#header {
  position: fixed; top: 24px; left: 36px; z-index: 21;
}
#header .label {
  font-family: 'Syne Mono', monospace;
  font-size: 9px; letter-spacing: 0.28em; text-transform: uppercase;
  color: var(--text-label); margin-bottom: 4px;
}
#title-edit {
  font-size: 22px; font-weight: 800;
  color: var(--text); letter-spacing: -0.02em;
  background: transparent; border: none; outline: none;
  font-family: 'Syne', sans-serif; width: 220px; padding: 0;
  caret-color: var(--text);
}

/* ── Category chips ─────────────────────────────────────── */
#cat-bar {
  position: fixed; top: 70px; left: 36px;
  display: flex; gap: 4px; align-items: center;
  z-index: 21;
  background: var(--panel-bg);
  backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 3px; padding: 4px;
}
.cat-chip {
  font-family: 'Syne Mono', monospace;
  font-size: 10px; letter-spacing: 0.12em; text-transform: uppercase;
  color: var(--text-dim); background: transparent; border: none;
  padding: 5px 11px; cursor: pointer; border-radius: 2px;
  transition: all 0.18s;
  display: flex; align-items: center; gap: 5px;
}
.cat-chip:hover { color: var(--text); }
.cat-chip.active { color: var(--tab-act-text); background: var(--tab-act-bg); }
.cat-chip.cat-hidden { opacity: 0.38; text-decoration: line-through; }
.cat-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
.cat-eye, .cat-del {
  font-size: 9px; color: var(--text-label);
  opacity: 0; transition: opacity 0.15s;
  background: none; border: none; cursor: pointer; padding: 0 2px;
}
.cat-chip:hover .cat-eye,
.cat-chip:hover .cat-del { opacity: 1; }
.cat-del:hover { color: #e06060 !important; }
.cat-add {
  font-family: 'Syne Mono', monospace; font-size: 13px;
  color: var(--text-dim); background: transparent;
  border: 1px dashed var(--border);
  padding: 3px 9px; cursor: pointer; border-radius: 2px;
  transition: all 0.18s;
}
.cat-add:hover { color: var(--text); border-color: var(--text-dim); }

/* ── Sets bar ────────────────────────────────────────────── */
#sets-bar {
  position: fixed; top: 24px; right: 36px;
  display: flex; align-items: center; gap: 5px; z-index: 21;
}
#sets-bar .s-label {
  font-family: 'Syne Mono', monospace;
  font-size: 9px; letter-spacing: 0.2em; text-transform: uppercase;
  color: var(--text-label); margin-right: 2px;
}
.set-btn {
  font-family: 'Syne Mono', monospace; font-size: 10px; letter-spacing: 0.1em;
  color: var(--text-dim); background: var(--btn-bg);
  border: 1px solid var(--border);
  padding: 5px 13px; cursor: pointer; border-radius: 2px; transition: all 0.18s;
}
.set-btn:hover { color: var(--text); }
.set-btn.active { color: var(--tab-act-text); background: var(--tab-act-bg); border-color: var(--btn-border); }
.set-new {
  font-family: 'Syne Mono', monospace; font-size: 11px;
  color: var(--text-dim); background: transparent;
  border: 1px dashed var(--border);
  padding: 5px 10px; cursor: pointer; border-radius: 2px; transition: all 0.18s;
}
.set-new:hover { color: var(--text); border-color: var(--text-dim); }

/* ── Theme toggle ────────────────────────────────────────── */
#theme-btn {
  position: fixed; top: 60px; right: 36px;
  font-family: 'Syne Mono', monospace; font-size: 9px; letter-spacing: 0.15em; text-transform: uppercase;
  color: var(--text-dim); background: var(--btn-bg);
  border: 1px solid var(--border);
  padding: 5px 11px; cursor: pointer; border-radius: 2px; z-index: 21; transition: all 0.18s;
}
#theme-btn:hover { color: var(--text); }

/* ── Done panel ──────────────────────────────────────────── */
#done-panel {
  position: fixed; top: 100px; right: 36px; width: 220px;
  background: var(--panel-bg); backdrop-filter: blur(14px);
  border: 1px solid var(--border); border-radius: 3px;
  padding: 14px 16px; max-height: 50vh; overflow-y: auto;
  display: none; z-index: 21;
}
#done-panel::-webkit-scrollbar { width: 3px; }
#done-panel::-webkit-scrollbar-thumb { background: var(--border); }
.done-hdr {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border);
}
.done-lbl {
  font-family: 'Syne Mono', monospace; font-size: 9px;
  letter-spacing: 0.25em; text-transform: uppercase; color: var(--text-dim);
}
.done-cnt {
  font-family: 'Syne Mono', monospace; font-size: 11px;
  color: var(--text-dim); background: var(--input-bg);
  padding: 2px 7px; border-radius: 10px;
}
#done-list { list-style: none; }
#done-list li {
  display: flex; align-items: center; gap: 8px;
  font-size: 12px; color: var(--text-dim);
  padding: 5px 0; border-bottom: 1px solid var(--border);
  text-decoration: line-through; text-decoration-color: var(--text-label);
}
#done-list li:last-child { border: none; }
.done-pip { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; opacity: 0.5; }
.done-time {
  font-family: 'Syne Mono', monospace; font-size: 9px;
  color: var(--text-label); margin-left: auto; white-space: nowrap;
}

/* ── Done zones (left / right) ───────────────────────────── */
.zone {
  position: fixed; top: 0; bottom: 76px; width: 110px;
  pointer-events: none; z-index: 10;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; transition: opacity 0.18s;
}
#zone-l { left: 0; }
#zone-r { right: 0; }
.zone.on { opacity: 1; }
.zone-badge {
  display: flex; flex-direction: column; align-items: center; gap: 7px;
}
.zone-ring {
  width: 56px; height: 56px; border-radius: 50%;
  border: 2px solid var(--zone-check);
  display: flex; align-items: center; justify-content: center;
  box-shadow: 0 0 18px var(--zone-glow), inset 0 0 14px rgba(0,0,0,0.08);
}
.zone-tick {
  font-size: 26px; line-height: 1; color: var(--zone-check);
  filter: drop-shadow(0 0 6px var(--zone-glow));
}
.zone-text {
  font-family: 'Syne Mono', monospace; font-size: 8px;
  letter-spacing: 0.22em; text-transform: uppercase;
  color: var(--zone-check);
}

/* ── Add bar ─────────────────────────────────────────────── */
#add-bar {
  position: fixed; bottom: 0; left: 0; right: 0; height: 76px;
  background: var(--bg);
  border-top: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center; gap: 10px;
  z-index: 22; pointer-events: all;
  transition: background 0.35s, border-color 0.35s;
}
#add-input {
  background: var(--input-bg); border: 1px solid var(--input-border);
  color: var(--text); font-family: 'Syne', sans-serif; font-size: 13px;
  padding: 10px 18px; border-radius: 2px; outline: none; width: 280px;
  transition: border-color 0.2s; caret-color: var(--text);
}
#add-input::placeholder { color: var(--text-label); }
#add-input:focus { border-color: var(--text-dim); }
#prio-sel {
  background: var(--input-bg); border: 1px solid var(--input-border);
  color: var(--btn-text); font-family: 'Syne Mono', monospace; font-size: 11px;
  padding: 10px 12px; border-radius: 2px; outline: none; cursor: pointer;
}
#add-btn {
  background: var(--btn-bg); border: 1px solid var(--btn-border);
  color: var(--btn-text); font-family: 'Syne', sans-serif; font-size: 12px;
  font-weight: 700; letter-spacing: 0.1em;
  padding: 10px 20px; cursor: pointer; border-radius: 2px; transition: all 0.18s;
}
#add-btn:hover { background: var(--tab-act-bg); color: var(--tab-act-text); }

/* ── Hint ────────────────────────────────────────────────── */
#hint {
  position: fixed; bottom: 84px; left: 50%; transform: translateX(-50%);
  font-family: 'Syne Mono', monospace; font-size: 9px;
  letter-spacing: 0.18em; text-transform: uppercase;
  color: var(--text-label); white-space: nowrap; z-index: 21; pointer-events: none;
}

/* ── Vis settings panel ──────────────────────────────────── */
#vis-btn {
  position: fixed; top: 90px; right: 36px;
  font-family: 'Syne Mono', monospace; font-size: 9px; letter-spacing: 0.15em; text-transform: uppercase;
  color: var(--text-dim); background: var(--btn-bg);
  border: 1px solid var(--border);
  padding: 5px 11px; cursor: pointer; border-radius: 2px; z-index: 21; transition: all 0.18s;
}
#vis-btn:hover { color: var(--text); }
#vis-panel {
  position: fixed; top: 120px; right: 36px; width: 200px;
  background: var(--panel-bg); backdrop-filter: blur(14px);
  border: 1px solid var(--border); border-radius: 3px;
  padding: 14px 16px; z-index: 21; display: none;
}
#vis-panel .vp-title {
  font-family: 'Syne Mono', monospace; font-size: 9px;
  letter-spacing: 0.25em; text-transform: uppercase;
  color: var(--text-dim); margin-bottom: 12px;
}
.vp-row { margin-bottom: 10px; }
.vp-row label {
  display: flex; justify-content: space-between; align-items: center;
  font-family: 'Syne Mono', monospace; font-size: 9px; letter-spacing: 0.12em;
  text-transform: uppercase; color: var(--text-dim); margin-bottom: 4px;
}
.vp-row label span { color: var(--text); }
.vp-row input[type=range] {
  width: 100%; accent-color: var(--tab-act-text);
  background: transparent; cursor: pointer;
}

/* ── Palette swatches ────────────────────────────────────── */
.vp-pal {
  display: flex; gap: 3px; align-items: center;
  padding: 5px 7px; border-radius: 2px; cursor: pointer;
  border: 1px solid var(--border); background: transparent;
  transition: border-color 0.15s;
}
.vp-pal:hover { border-color: var(--text-dim); }
.vp-pal.active { border-color: var(--text); }
.vp-pal-dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }

/* ── Tooltip ─────────────────────────────────────────────── */
#tooltip {
  position: fixed; background: var(--panel-bg);
  border: 1px solid var(--border); padding: 8px 12px; border-radius: 3px;
  font-size: 11px; color: var(--text); pointer-events: none; opacity: 0;
  transition: opacity 0.15s; font-family: 'Syne Mono', monospace;
  max-width: 200px; z-index: 30;
}
#tooltip.show { opacity: 1; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="header">
  <div class="label">Aktuelle Todos</div>
  <input id="title-edit" type="text" value="Todo Bälle" />
</div>

<div id="cat-bar"></div>

<div id="sets-bar"><span class="s-label">Sets</span></div>

<button id="theme-btn" onclick="toggleTheme()">◐ Hell</button>
<button id="vis-btn" onclick="toggleVisPanel()">⚙ Optik</button>
<div id="vis-panel">
  <div class="vp-title">Visualisierung</div>
  <div class="vp-row">
    <label>Linien <span id="lbl-density">1.0</span></label>
    <input type="range" id="sl-density" min="0.2" max="1.5" step="0.1" value="1.0"
      oninput="visDensity=+this.value; document.getElementById('lbl-density').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Speed <span id="lbl-speed">1.0</span></label>
    <input type="range" id="sl-speed" min="0.2" max="2.5" step="0.1" value="1.0"
      oninput="visSpeed=+this.value; document.getElementById('lbl-speed').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Linienhelligkeit <span id="lbl-intensity">1.0</span></label>
    <input type="range" id="sl-intensity" min="0.2" max="1.5" step="0.1" value="1.0"
      oninput="visIntensity=+this.value; document.getElementById('lbl-intensity').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Kugelkörper <span id="lbl-ball">1.0</span></label>
    <input type="range" id="sl-ball" min="0.1" max="1.5" step="0.1" value="1.0"
      oninput="visBallOpacity=+this.value; document.getElementById('lbl-ball').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Innenglow <span id="lbl-glow">1.0</span></label>
    <input type="range" id="sl-glow" min="0.0" max="3.0" step="0.1" value="1.0"
      oninput="visGlow=+this.value; document.getElementById('lbl-glow').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Sockelton <span id="lbl-base">1.0</span></label>
    <input type="range" id="sl-base" min="0.0" max="2.0" step="0.05" value="1.0"
      oninput="visBallBase=+this.value; document.getElementById('lbl-base').textContent=this.value">
  </div>
  <div class="vp-row">
    <label>Kreislinien <span id="lbl-bgdark">1.0</span></label>
    <input type="range" id="sl-bgdark" min="0.0" max="3.0" step="0.1" value="1.0"
      oninput="visBgDark=+this.value; document.getElementById('lbl-bgdark').textContent=this.value">
  </div>
  <div class="vp-row" style="margin-top:4px">
    <label style="margin-bottom:6px">Beige Farben</label>
    <div style="display:flex;flex-wrap:wrap;gap:6px" id="pal-row"></div>
  </div>
</div>

<div id="done-panel">
  <div class="done-hdr">
    <span class="done-lbl">Erledigt</span>
    <span class="done-cnt" id="done-cnt">0</span>
  </div>
  <ul id="done-list"></ul>
</div>

<div class="zone" id="zone-l">
  <div class="zone-badge">
    <div class="zone-ring"><span class="zone-tick">✓</span></div>
    <span class="zone-text">Erledigt</span>
  </div>
</div>
<div class="zone" id="zone-r">
  <div class="zone-badge">
    <div class="zone-ring"><span class="zone-tick">✓</span></div>
    <span class="zone-text">Erledigt</span>
  </div>
</div>

<div id="hint">Links / Rechts raus = Erledigt · Doppelklick = Löschen · Nach oben werfen</div>

<div id="add-bar">
  <input id="add-input" type="text" placeholder="Neues Todo …" />
  <select id="prio-sel"></select>
  <button id="add-btn" onclick="addTodo()">+ Hinzufügen</button>
</div>

<div id="tooltip"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
'use strict';
const { Engine, Bodies, Body, Composite, Events, Mouse, MouseConstraint } = Matter;

// ─── VIS SETTINGS ────────────────────────────────────────────────────────────
let visDensity      = 1.0;
let visSpeed        = 1.0;
let visIntensity    = 1.0;
let visBallOpacity  = 1.0;
let visGlow         = 1.0;
let visBallBase     = 1.0;
let visBgDark       = 0.0;   // 0 = current bg, 1 = deeper black

const visPresets = {
  dark:  { density: 1.0, speed: 1.0, intensity: 1.0, ball: 1.0, glow: 1.0, base: 0.0, bgDark: 1.0 },
  beige: { density: 1.0, speed: 1.0, intensity: 1.0, ball: 1.0, glow: 1.0, base: 1.0, bgDark: 1.0 },
};

function visSave() {
  visPresets[theme] = { density: visDensity, speed: visSpeed, intensity: visIntensity, ball: visBallOpacity, glow: visGlow, base: visBallBase, bgDark: visBgDark };
}

function visLoad(t) {
  const p = visPresets[t];
  visDensity = p.density; visSpeed = p.speed; visIntensity = p.intensity; visBallOpacity = p.ball; visGlow = p.glow ?? 1.0; visBallBase = p.base ?? 0.0; visBgDark = p.bgDark ?? 1.0;
  document.getElementById('sl-density').value   = p.density;
  document.getElementById('sl-speed').value     = p.speed;
  document.getElementById('sl-intensity').value = p.intensity;
  document.getElementById('sl-ball').value      = p.ball;
  document.getElementById('sl-glow').value      = visGlow;
  document.getElementById('sl-base').value      = visBallBase;
  document.getElementById('sl-bgdark').value    = visBgDark;
  document.getElementById('lbl-density').textContent   = p.density;
  document.getElementById('lbl-speed').textContent     = p.speed;
  document.getElementById('lbl-intensity').textContent = p.intensity;
  document.getElementById('lbl-ball').textContent      = p.ball;
  document.getElementById('lbl-glow').textContent      = visGlow;
  document.getElementById('lbl-base').textContent      = visBallBase;
  document.getElementById('lbl-bgdark').textContent    = visBgDark;
}

function toggleVisPanel() {
  const p = document.getElementById('vis-panel');
  p.style.display = p.style.display === 'block' ? 'none' : 'block';
}

// ─── BEIGE COLORS ────────────────────────────────────────────────────────────
const beigeColors = {
  urgent:   '#48403A',
  workflow: '#5A7880',
  reminder: '#c0bab0',
};

function buildPaletteRow() {
  const row = document.getElementById('pal-row');
  row.innerHTML = '';
  const cats = [
    { key: 'urgent',   label: 'Drng' },
    { key: 'workflow', label: 'Work' },
    { key: 'reminder', label: 'Erin' },
  ];
  cats.forEach(c => {
    const wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;align-items:center;gap:5px;flex:0 0 calc(50% - 3px);';
    const inp = document.createElement('input');
    inp.type  = 'color';
    inp.value = beigeColors[c.key];
    inp.style.cssText = 'width:28px;height:20px;padding:1px;border:1px solid var(--border);border-radius:2px;background:transparent;cursor:pointer;flex-shrink:0;';
    inp.oninput = () => {
      beigeColors[c.key]    = inp.value;
      T.beige.colors[c.key] = inp.value;
      rebuildCatBar();
    };
    const lbl = document.createElement('label');
    lbl.style.cssText = 'margin-bottom:0;font-family:\'Syne Mono\',monospace;font-size:9px;letter-spacing:.10em;text-transform:uppercase;color:var(--text-dim);white-space:nowrap;';
    lbl.textContent = c.label;
    wrap.appendChild(inp);
    wrap.appendChild(lbl);
    row.appendChild(wrap);
  });
  // Apply current picks to theme
  cats.forEach(c => { T.beige.colors[c.key] = beigeColors[c.key]; });
}

// ─── THEME ──────────────────────────────────────────────────────────────────
let theme = 'dark';

const T = {
  dark: {
    bg:          '#111118',
    orbit:       'rgba(255,255,255,0.022)',
    floor:       'rgba(255,255,255,0.18)',
    wire:        'rgba(255,255,255,0.20)',
    orbitRing:   'rgba(255,255,255,0.10)',
    specular:    'rgba(255,255,255,0.28)',
    shadow:      'rgba(0,0,0,0.35)',
    ballText:    'rgba(255,255,255,0.88)',
    counterText: 'rgba(255,255,255,0.14)',
    zone:        { fill: 'rgba(60,200,100,', border: 'rgba(60,200,100,0.18)' },
    colors: {
      urgent:   '#B8903A',
      workflow: '#2C4A7C',
      reminder: '#7A4E30',
    }
  },
  beige: {
    bg:          '#ede8dc',
    orbit:       'rgba(8,5,3,0.06)',
    floor:       'rgba(8,5,3,0.35)',
    wire:        'rgba(8,5,3,0.18)',
    orbitRing:   'rgba(8,5,3,0.10)',
    specular:    'rgba(8,5,3,0.12)',
    shadow:      'rgba(8,5,3,0.18)',
    ballText:    'rgba(8,5,3,0.88)',
    counterText: 'rgba(8,5,3,0.28)',
    zone:        { fill: 'rgba(40,110,65,', border: 'rgba(40,110,65,0.18)' },
    colors: {
      urgent:   '#48403A',
      workflow: '#5A7880',
      reminder: '#506470',
    }
  }
};

function getT() { return T[theme]; }
function getBallColor(type) {
  return getT().colors[type] || getT().colors.workflow;
}

function toggleTheme() {
  visSave();
  theme = theme === 'dark' ? 'beige' : 'dark';
  document.body.classList.toggle('beige', theme === 'beige');
  document.getElementById('theme-btn').textContent = theme === 'dark' ? '◐ Hell' : '◑ Dunkel';
  visLoad(theme);
  rebuildCatBar();
  renderDoneList();
}

// ─── CATEGORIES ──────────────────────────────────────────────────────────────
let categories = [
  { id: 'urgent',   name: 'Dringend',   visible: true },
  { id: 'workflow', name: 'Workflow',    visible: true },
  { id: 'reminder', name: 'Erinnerung', visible: true },
];
let activeFilter = 'all';

const EXTRA_COLORS_DARK  = ['#B07050','#8858A8','#48A0A8','#A09840','#5888A0','#A04870'];
const EXTRA_COLORS_BEIGE = ['#7A5038','#604878','#386870','#706830','#386878','#703048'];

function rebuildCatBar() {
  const bar = document.getElementById('cat-bar');
  bar.innerHTML = '';

  const allBtn = document.createElement('button');
  allBtn.className = 'cat-chip' + (activeFilter === 'all' ? ' active' : '');
  allBtn.textContent = 'Alle';
  allBtn.onclick = () => setFilter('all');
  bar.appendChild(allBtn);

  categories.forEach(cat => {
    const chip = document.createElement('button');
    chip.className = 'cat-chip'
      + (activeFilter === cat.id ? ' active' : '')
      + (!cat.visible ? ' cat-hidden' : '');

    const dot = document.createElement('span');
    dot.className = 'cat-dot';
    dot.style.background = getBallColor(cat.id);

    const nameEl = document.createElement('span');
    nameEl.textContent = cat.name;

    const eye = document.createElement('button');
    eye.className = 'cat-eye';
    eye.textContent = cat.visible ? '○' : '●';
    eye.title = cat.visible ? 'Ausblenden' : 'Einblenden';
    eye.onclick = e => { e.stopPropagation(); toggleCatVis(cat.id); };

    const del = document.createElement('button');
    del.className = 'cat-del';
    del.textContent = '×';
    del.title = 'Kategorie löschen';
    del.onclick = e => { e.stopPropagation(); deleteCat(cat.id); };

    chip.appendChild(dot);
    chip.appendChild(nameEl);
    chip.appendChild(eye);
    chip.appendChild(del);
    chip.onclick = () => setFilter(cat.id);
    chip.ondblclick = () => renameCat(cat.id);
    bar.appendChild(chip);
  });

  const addBtn = document.createElement('button');
  addBtn.className = 'cat-add';
  addBtn.textContent = '＋';
  addBtn.title = 'Neue Kategorie';
  addBtn.onclick = addCat;
  bar.appendChild(addBtn);

  // Rebuild prio select
  const sel = document.getElementById('prio-sel');
  const prev = sel.value;
  sel.innerHTML = categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
  if (categories.find(c => c.id === prev)) sel.value = prev;
  else if (categories.length > 1) sel.value = categories[1].id;
}

function setFilter(f) {
  activeFilter = f;
  rebuildCatBar();
  applyFilter();
}

function toggleCatVis(id) {
  const cat = categories.find(c => c.id === id);
  if (cat) { cat.visible = !cat.visible; rebuildCatBar(); applyFilter(); }
}

function deleteCat(id) {
  const count = balls.filter(b => b.data.type === id).length;
  const msg   = count > 0
    ? `Kategorie löschen? ${count} Ball/Bälle werden ebenfalls entfernt.`
    : 'Kategorie löschen?';
  if (!confirm(msg)) return;
  // Remove balls of this type from world
  balls = balls.filter(b => {
    if (b.data.type !== id) return true;
    if (b.inWorld) Composite.remove(world, b.body);
    return false;
  });
  if (selectedIdx >= balls.length) selectedIdx = -1;
  // Remove from categories
  categories = categories.filter(c => c.id !== id);
  if (activeFilter === id) activeFilter = 'all';
  rebuildCatBar();
  renderDoneList();
}

function renameCat(id) {
  const cat = categories.find(c => c.id === id);
  if (!cat) return;
  const n = prompt('Kategorie umbenennen:', cat.name);
  if (n && n.trim()) { cat.name = n.trim(); rebuildCatBar(); }
}

function addCat() {
  const n = prompt('Name der neuen Kategorie:');
  if (!n || !n.trim()) return;
  const id = 'cat_' + Date.now();
  const idx = categories.length;
  T.dark.colors[id]  = EXTRA_COLORS_DARK[idx  % EXTRA_COLORS_DARK.length];
  T.beige.colors[id] = EXTRA_COLORS_BEIGE[idx % EXTRA_COLORS_BEIGE.length];
  categories.push({ id, name: n.trim(), visible: true });
  rebuildCatBar();
}

// ─── SETS ────────────────────────────────────────────────────────────────────
let sets = { 'Praxis': [], 'Privat': [] };
let activeSet = 'Praxis';

function buildSetsBar() {
  const bar = document.getElementById('sets-bar');
  bar.innerHTML = '<span class="s-label">Sets</span>';
  Object.keys(sets).forEach(name => {
    const btn = document.createElement('button');
    btn.className = 'set-btn' + (name === activeSet ? ' active' : '');
    btn.textContent = name;
    btn.onclick = () => switchSet(name);
    bar.appendChild(btn);
  });
  const newBtn = document.createElement('button');
  newBtn.className = 'set-new';
  newBtn.textContent = '+ Neu';
  newBtn.onclick = addSet;
  bar.appendChild(newBtn);
}

function switchSet(name) {
  sets[activeSet] = balls.map(b => ({ ...b.data }));
  balls.forEach(b => { if (b.inWorld) Composite.remove(world, b.body); });
  balls = [];
  doneTodos = [];
  renderDoneList();
  activeSet = name;
  buildSetsBar();
  const saved = sets[name] || [];
  saved.forEach((todo, i) => setTimeout(() => spawnBall(todo), i * 80));
}

function addSet() {
  const n = prompt('Name des neuen Sets:');
  if (!n || !n.trim()) return;
  sets[n.trim()] = [];
  switchSet(n.trim());
}

// ─── PHYSICS SETUP ───────────────────────────────────────────────────────────
const SIZES = { urgent: 62, workflow: 50, reminder: 38 };

const INITIAL = [
  { text: 'Kaffeemaschine\nentkalken',  type: 'reminder' },
  { text: 'IVP Makro\ntesten',          type: 'workflow'  },
  { text: 'PsychoEQ\ntesten',           type: 'workflow'  },
  { text: 'Stundenabgleich\nMaerz',     type: 'urgent'    },
  { text: 'WireGuard\ndokum.',          type: 'reminder'  },
  { text: 'Netzwerkplan\nfinalis.',     type: 'workflow'  },
  { text: 'Protokoll\nTeammeeting',     type: 'urgent'    },
  { text: 'BTT Shortcuts\naufraeum.',   type: 'reminder'  },
];

let W = window.innerWidth;
let H = window.innerHeight - 76;
let nextId = 100;

const canvas = document.getElementById('c');
canvas.width = W; canvas.height = H;
const ctx = canvas.getContext('2d');

const engine = Engine.create({ gravity: { x: 0, y: 0.22 } });
const world  = engine.world;

function buildWalls() {
  return [
    Bodies.rectangle(W/2, H + 25,  W + 200, 50, { isStatic: true, label: 'wall' }),
    Bodies.rectangle(-25, H/2,      50, H * 5,   { isStatic: true, label: 'wall' }),
    Bodies.rectangle(W + 25, H/2,   50, H * 5,   { isStatic: true, label: 'wall' }),
    // NO top wall — balls fly up and return via gravity
  ];
}
let walls = buildWalls();
Composite.add(world, walls);

const mouse = Mouse.create(canvas);
mouse.element.removeEventListener('mousewheel',     mouse.mousewheel);
mouse.element.removeEventListener('DOMMouseScroll', mouse.mousewheel);
const mc = MouseConstraint.create(engine, {
  mouse,
  constraint: { stiffness: 0.07, damping: 0.08, render: { visible: false } }
});
Composite.add(world, mc);

// ─── BALL STATE ──────────────────────────────────────────────────────────────
let balls     = [];
let doneTodos = [];

function spawnBall(todo) {
  const r = SIZES[todo.type] || 44;
  const x = W * 0.2 + Math.random() * W * 0.6;
  const y = 100 + Math.random() * (H * 0.45);
  const body = Bodies.circle(x, y, r, {
    restitution: 0.55, friction: 0.012, frictionAir: 0.014,
    density: 0.003, label: 'ball'
  });
  Body.setVelocity(body, { x: (Math.random()-0.5)*3, y: (Math.random()-0.5)*2 });
  const id = todo.id || nextId++;
  const obj = { body, data: { ...todo, id }, r, id, visible: true, inWorld: true };
  Composite.add(world, body);
  balls.push(obj);
  applyFilter();
}

function addTodo() {
  const inp  = document.getElementById('add-input');
  const type = document.getElementById('prio-sel').value || 'workflow';
  const text = inp.value.trim();
  if (!text) return;
  const words = text.split(' ');
  const half  = Math.ceil(words.length / 2);
  const disp  = words.length > 1
    ? words.slice(0, half).join(' ') + '\n' + words.slice(half).join(' ')
    : text;
  spawnBall({ text: disp, type, id: nextId++ });
  inp.value = '';
  inp.focus();
}

document.getElementById('add-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') addTodo();
});

// ─── FILTER ──────────────────────────────────────────────────────────────────
function applyFilter() {
  balls.forEach(ball => {
    const cat  = categories.find(c => c.id === ball.data.type);
    const show = (cat ? cat.visible : true)
              && (activeFilter === 'all' || ball.data.type === activeFilter);
    const was  = ball.visible;
    ball.visible = show;
    if (!show && was && ball.inWorld) {
      Composite.remove(world, ball.body); ball.inWorld = false;
    } else if (show && !was && !ball.inWorld) {
      const x = W * 0.2 + Math.random() * W * 0.6;
      const y = 100 + Math.random() * (H * 0.35);
      const nb = Bodies.circle(x, y, ball.r, {
        restitution: 0.55, friction: 0.012, frictionAir: 0.014,
        density: 0.003, label: 'ball'
      });
      Body.setVelocity(nb, { x: (Math.random()-0.5)*3, y: (Math.random()-0.5)*2 });
      ball.body = nb;
      Composite.add(world, nb); ball.inWorld = true;
    }
  });
}

// ─── DONE ZONES ──────────────────────────────────────────────────────────────
const ZONE_W = 110;
let dragState = null;

function getDragBall() {
  if (!dragState) return null;
  return balls[dragState.idx] || null;
}

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const mx = e.clientX, my = e.clientY;
  for (let i = 0; i < balls.length; i++) {
    const b = balls[i];
    if (!b.visible) continue;
    const dx = mx - b.body.position.x, dy = my - b.body.position.y;
    if (dx*dx + dy*dy < b.r*b.r) { dragState = { idx: i }; break; }
  }
});

window.addEventListener('mousemove', e => {
  window._mx = e.clientX;
  updateZones();
});

window.addEventListener('mouseup', () => {
  checkDoneRelease();
  dragState = null;
  document.getElementById('zone-l').classList.remove('on');
  document.getElementById('zone-r').classList.remove('on');
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  const mx = t.clientX, my = t.clientY;
  for (let i = 0; i < balls.length; i++) {
    const b = balls[i];
    if (!b.visible) continue;
    const dx = mx - b.body.position.x, dy = my - b.body.position.y;
    if (dx*dx + dy*dy < b.r * b.r * 1.6) { dragState = { idx: i }; break; }
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  updateZones();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  checkDoneRelease();
  dragState = null;
  document.getElementById('zone-l').classList.remove('on');
  document.getElementById('zone-r').classList.remove('on');
}, { passive: false });

function updateZones() {
  const ball = getDragBall();
  if (!ball || !ball.visible) return;
  const bx = ball.body.position.x;
  document.getElementById('zone-l').classList.toggle('on', bx < ZONE_W);
  document.getElementById('zone-r').classList.toggle('on', bx > W - ZONE_W);
}

function checkDoneRelease() {
  const ball = getDragBall();
  if (!ball || !ball.visible) return;
  const bx = ball.body.position.x;
  if (bx < ZONE_W || bx > W - ZONE_W) markDone(dragState.idx);
}

function markDone(idx) {
  if (idx < 0 || idx >= balls.length) return;
  const ball = balls[idx];
  const now  = new Date();
  const time = now.getHours() + ':' + String(now.getMinutes()).padStart(2,'0');
  doneTodos.unshift({ ...ball.data, time });
  if (ball.inWorld) Composite.remove(world, ball.body);
  balls.splice(idx, 1);
  if (selectedIdx === idx)     selectedIdx = -1;
  else if (selectedIdx > idx)  selectedIdx--;
  dragState = null;
  renderDoneList();
}

function renderDoneList() {
  const panel = document.getElementById('done-panel');
  const list  = document.getElementById('done-list');
  document.getElementById('done-cnt').textContent = doneTodos.length;
  panel.style.display = doneTodos.length > 0 ? 'block' : 'none';
  list.innerHTML = doneTodos.map(t => {
    const col = getBallColor(t.type);
    return `<li>
      <span class="done-pip" style="background:${col}"></span>
      ${t.text.replace('\n', ' ')}
      <span class="done-time">${t.time}</span>
    </li>`;
  }).join('');
}

// ─── DOUBLE CLICK DELETE ──────────────────────────────────────────────────────
canvas.addEventListener('dblclick', e => {
  const mx = e.clientX, my = e.clientY;
  for (let i = balls.length - 1; i >= 0; i--) {
    const b = balls[i];
    if (!b.visible) continue;
    const dx = mx - b.body.position.x, dy = my - b.body.position.y;
    if (dx*dx + dy*dy < b.r*b.r) {
      if (b.inWorld) Composite.remove(world, b.body);
      balls.splice(i, 1);
      if (selectedIdx === i)     selectedIdx = -1;
      else if (selectedIdx > i)  selectedIdx--;
      break;
    }
  }
});

// ─── HOVER + SELECT ───────────────────────────────────────────────────────────
let hoveredIdx  = -1;
let selectedIdx = -1;
const tooltip   = document.getElementById('tooltip');

canvas.addEventListener('mousemove', e => {
  const mx = e.clientX, my = e.clientY;
  let found = -1;
  balls.forEach((b, i) => {
    if (!b.visible) return;
    const dx = mx - b.body.position.x, dy = my - b.body.position.y;
    if (dx*dx + dy*dy < b.r*b.r) found = i;
  });
  hoveredIdx = found;
  canvas.style.cursor = found >= 0 ? 'pointer' : 'default';
  if (found >= 0) {
    tooltip.textContent = balls[found].data.text.replace('\n', ' ');
    tooltip.style.left = (e.clientX + 14) + 'px';
    tooltip.style.top  = (e.clientY - 10) + 'px';
    tooltip.classList.add('show');
  } else {
    tooltip.classList.remove('show');
  }
});

canvas.addEventListener('click', () => {
  if (dragState) return;
  selectedIdx = hoveredIdx === selectedIdx ? -1 : hoveredIdx;
});

// ─── SCROLL TO RESIZE ────────────────────────────────────────────────────────
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  if (selectedIdx < 0 || selectedIdx >= balls.length) return;
  const ball  = balls[selectedIdx];
  const newR  = Math.max(20, Math.min(120, ball.r + (e.deltaY > 0 ? -4 : 4)));
  if (newR === ball.r) return;
  const pos = ball.body.position, vel = ball.body.velocity;
  Composite.remove(world, ball.body);
  const nb = Bodies.circle(pos.x, pos.y, newR, {
    restitution: 0.55, friction: 0.012, frictionAir: 0.014,
    density: 0.003, label: 'ball'
  });
  Body.setVelocity(nb, vel);
  Composite.add(world, nb);
  ball.body = nb; ball.r = newR;
  mc.body = null;
}, { passive: false });

// ─── CONTAINMENT (horizontal nudge only — vertical free) ─────────────────────
Events.on(engine, 'afterUpdate', () => {
  balls.forEach(b => {
    if (!b.visible) return;
    const { x, y } = b.body.position;
    // Gentle horizontal centering
    const dx = (W / 2) - x;
    if (Math.abs(dx) > W * 0.42) {
      Body.applyForce(b.body, b.body.position, { x: dx * 0.000028, y: 0 });
    }
    // If ball escapes far above, nudge it back
    if (y < -H * 0.6) {
      Body.applyForce(b.body, b.body.position, { x: 0, y: b.body.mass * 0.006 });
    }
  });
});

Matter.Runner.run(Matter.Runner.create(), engine);

// ─── ANIMATION CLOCK ────────────────────────────────────────────────────────
let animTime = 0; // incremented each frame in drawFrame

// ─── COLOR UTILS ─────────────────────────────────────────────────────────────
function hexRgb(hex) {
  if (hex.length === 4) hex = '#' + hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
  return { r: parseInt(hex.slice(1,3),16), g: parseInt(hex.slice(3,5),16), b: parseInt(hex.slice(5,7),16) };
}
function lighter(hex, a) {
  const c = hexRgb(hex);
  return `rgb(${Math.min(255,c.r+a)},${Math.min(255,c.g+a)},${Math.min(255,c.b+a)})`;
}
function darker(hex, a) {
  const c = hexRgb(hex);
  return `rgb(${Math.max(0,c.r-a)},${Math.max(0,c.g-a)},${Math.max(0,c.b-a)})`;
}

// ─── SPEED-LINE HELPERS ───────────────────────────────────────────────────────

// Point on a rotated ellipse at parameter t
function ellipseP(cx, cy, rx, ry, rot, t) {
  const cr = Math.cos(rot), sr = Math.sin(rot);
  const ct = Math.cos(t),   st = Math.sin(t);
  return { x: cx + ct*rx*cr - st*ry*sr,
           y: cy + ct*rx*sr + st*ry*cr };
}

// Speed-line ellipse: continuous base ring + 2 tapered dashes
function speedEllipse(cx, cy, rx, ry, rot, lineRc, baseAlpha, phaseShift) {
  const col = `rgba(${lineRc.r},${lineRc.g},${lineRc.b},`;
  ctx.beginPath();
  for (let i = 0; i <= 64; i++) {
    const t = (i / 64) * Math.PI * 2;
    const p = ellipseP(cx, cy, rx, ry, rot, t);
    i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
  }
  ctx.closePath();
  ctx.strokeStyle = col + (baseAlpha * 0.28).toFixed(2) + ')';
  ctx.lineWidth = 0.5; ctx.lineCap = 'round'; ctx.stroke();
  for (let d = 0; d < 2; d++) {
    const tc  = (phaseShift + d * Math.PI) % (Math.PI * 2);
    const len = 0.45;
    const N   = 14;
    for (let i = 0; i < N - 1; i++) {
      const t0       = tc - len / 2 + (i / N) * len;
      const t1       = tc - len / 2 + ((i + 1) / N) * len;
      const progress = Math.sin((i / (N - 1)) * Math.PI);
      const p0 = ellipseP(cx, cy, rx, ry, rot, t0);
      const p1 = ellipseP(cx, cy, rx, ry, rot, t1);
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y);
      ctx.strokeStyle = col + (baseAlpha * (0.25 + progress * 0.75)).toFixed(2) + ')';
      ctx.lineWidth   = 0.15 + progress * 1.2;
      ctx.lineCap     = 'round'; ctx.stroke();
    }
  }
}

// Moving spark: glow halo + bright core + long fading trail
function ellipseSpark(cx, cy, rx, ry, rot, sparkT, lineRc) {
  const col = `rgba(${lineRc.r},${lineRc.g},${lineRc.b},`;
  const p   = ellipseP(cx, cy, rx, ry, rot, sparkT);
  const g   = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 4);
  g.addColorStop(0, col + '0.70)'); g.addColorStop(0.4, col + '0.22)'); g.addColorStop(1, col + '0)');
  ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill();
  ctx.beginPath(); ctx.arc(p.x, p.y, 1.2, 0, Math.PI * 2); ctx.fillStyle = col + '0.95)'; ctx.fill();
  for (let i = 1; i <= 8; i++) {
    const tp = ellipseP(cx, cy, rx, ry, rot, sparkT - i * 0.10);
    const a  = 0.40 - i * 0.05;
    if (a <= 0) continue;
    ctx.beginPath(); ctx.arc(tp.x, tp.y, Math.max(0.5, 1.4 - i * 0.15), 0, Math.PI * 2);
    ctx.fillStyle = col + a.toFixed(2) + ')'; ctx.fill();
  }
}

// ─── DRAW WIREFRAME BALL ──────────────────────────────────────────────────────
// Pure wireframe:  faint glass tint + speed-line ellipses (category-colored in
// dark mode, dark accents in beige) + moving spark per ellipse.

function drawBall(b, hovered, selected) {
  const { x, y } = b.body.position;
  const r   = b.r;
  const col = getBallColor(b.data.type);
  const rc  = hexRgb(col);
  const Th  = getT();
  const lightBg    = theme === 'beige';
  const isDarkBall = (rc.r + rc.g + rc.b) < 260;
  const bp         = b.id * 2.618;

  // Line color inside ball — contrast against ball body
  const lrc = lightBg
    ? (isDarkBall
        ? { r: Math.min(255,rc.r+160), g: Math.min(255,rc.g+160), b: Math.min(255,rc.b+155) }
        : { r: Math.max(0,rc.r-80),    g: Math.max(0,rc.g-80),    b: Math.max(0,rc.b-80) })
    : rc;
  // Line color outside ball — contrast against background
  const orc = lightBg
    ? { r: Math.max(0,rc.r-30), g: Math.max(0,rc.g-30), b: Math.max(0,rc.b-30) }
    : rc;

  // 1. Hover/select glow (starts at edge, no fill inside)
  if (hovered || selected) {
    const a  = selected ? 0.22 : 0.13;
    const gc = ctx.createRadialGradient(x, y, r, x, y, r*2.4);
    gc.addColorStop(0, `rgba(${lrc.r},${lrc.g},${lrc.b},${a})`);
    gc.addColorStop(1, `rgba(${lrc.r},${lrc.g},${lrc.b},0)`);
    ctx.beginPath(); ctx.arc(x, y, r*2.4, 0, Math.PI*2); ctx.fillStyle = gc; ctx.fill();
  }

  // 2. Drop shadow
  const sh = ctx.createRadialGradient(x+4, y+7, 0, x+4, y+7, r*1.3);
  sh.addColorStop(0, lightBg ? 'rgba(0,0,0,.20)' : 'rgba(0,0,0,.55)');
  sh.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.beginPath(); ctx.arc(x+4, y+7, r*1.3, 0, Math.PI*2); ctx.fillStyle = sh; ctx.fill();

  // 2.5 Solid base fill — blocks bright background bleed-through
  if (visBallBase > 0.01) {
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(${rc.r},${rc.g},${rc.b},${Math.min(1, 0.50 * visBallBase).toFixed(2)})`;
    ctx.fill();
  }

  // 3. Glass body
  const bg = ctx.createRadialGradient(x-r*.28, y-r*.30, r*.04, x+r*.15, y+r*.15, r*1.06);
  const bo = visBallOpacity;
  bg.addColorStop(0,   `rgba(${Math.min(255,rc.r+55)},${Math.min(255,rc.g+65)},${Math.min(255,rc.b+75)},${Math.min(1,.42*bo).toFixed(2)})`);
  bg.addColorStop(.38, `rgba(${rc.r},${rc.g},${rc.b},${Math.min(1,.68*bo).toFixed(2)})`);
  bg.addColorStop(.72, `rgba(${Math.max(0,rc.r-28)},${Math.max(0,rc.g-28)},${Math.max(0,rc.b-18)},${Math.min(1,.86*bo).toFixed(2)})`);
  bg.addColorStop(1,   `rgba(${Math.max(0,rc.r-55)},${Math.max(0,rc.g-55)},${Math.max(0,rc.b-42)},${Math.min(1,.96*bo).toFixed(2)})`);
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = bg; ctx.fill();

  // 4. Inner refraction glow — white
  const ig = ctx.createRadialGradient(x+r*.28, y+r*.32, 0, x+r*.28, y+r*.32, r*.68);
  ig.addColorStop(0, `rgba(255,255,255,${Math.min(1,(lightBg ? .06 : .20)*visGlow).toFixed(2)})`);
  ig.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = ig; ctx.fill();

  // 5. Speedlines + sparks clipped inside
  const hA   = hovered ? 0.98 : 0.92;
  const ELPS = [
    { rx: r*.97, ry: r*.19, rot: 0,             cy: y,       spd: .90 },
    { rx: r*.90, ry: r*.16, rot: 0,             cy: y-r*.36, spd: 1.28 },
    { rx: r*.90, ry: r*.16, rot: 0,             cy: y+r*.36, spd: .62 },
    { rx: r*.76, ry: r*.13, rot: 0,             cy: y-r*.62, spd: 1.55 },
    { rx: r*.76, ry: r*.13, rot: 0,             cy: y+r*.62, spd: .38 },
    { rx: r*.52, ry: r*.09, rot: 0,             cy: y-r*.82, spd: 1.80 },
    { rx: r*.52, ry: r*.09, rot: 0,             cy: y+r*.82, spd: .22 },
    { rx: r*.17, ry: r*.97, rot: 0,             cy: y,       spd: 1.65 },
    { rx: r*.17, ry: r*.97, rot: Math.PI/2.7,   cy: y,       spd: .42 },
    { rx: r*.17, ry: r*.97, rot: Math.PI/4,     cy: y,       spd: 1.10 },
    { rx: r*.17, ry: r*.97, rot: -Math.PI/3.4,  cy: y,       spd: .78 },
    { rx: r*.17, ry: r*.97, rot: Math.PI/1.55,  cy: y,       spd: 1.38 },
  ];
  const baseE = lightBg
    ? (r < 45 ? 2 : r < 62 ? 3 : 5)
    : (r < 45 ? 3 : r < 62 ? 5 : 8);
  const maxE = Math.max(1, Math.round(baseE * visDensity));

  ctx.save();
  ctx.beginPath(); ctx.arc(x, y, r-0.5, 0, Math.PI*2); ctx.clip();
  ELPS.slice(0, maxE).forEach((e, i) => {
    const hs   = lightBg && i >= Math.floor(maxE * 2 / 3);
    const sm   = (hs ? 3.8 : 1.1) * visSpeed;
    speedEllipse(x, e.cy, e.rx, e.ry, e.rot, lrc, hA * visIntensity, bp + i*1.2 + animTime*e.spd*sm);
    ellipseSpark (x, e.cy, e.rx, e.ry, e.rot, animTime*e.spd*sm*1.3 + bp + i*.9, lrc);
  });
  ctx.restore();

  // 6. Outer rings — clipped to outside ball
  ctx.save();
  ctx.beginPath();
  ctx.rect(-10, -10, W+20, H+20);
  ctx.arc(x, y, r+1, 0, Math.PI*2, true);
  ctx.clip('evenodd');

  function ringLines(orRx, orRy, rot, tSpd, baseA, pulseA) {
    const cr = Math.cos(rot), sr = Math.sin(rot), N = 72;
    for (let i = 0; i < N; i++) {
      const t0 = (i/N)*Math.PI*2, t1 = ((i+1)/N)*Math.PI*2;
      const pulse = Math.pow(Math.max(0, Math.sin(t0*2.2 + bp + animTime*tSpd)), 5);
      const lw = .10 + pulse*1.4, alpha = baseA + pulse*pulseA;
      if (alpha < .025) continue;
      const x0 = x+Math.cos(t0)*orRx*cr-Math.sin(t0)*orRy*sr;
      const y0 = y+Math.cos(t0)*orRx*sr+Math.sin(t0)*orRy*cr;
      const x1 = x+Math.cos(t1)*orRx*cr-Math.sin(t1)*orRy*sr;
      const y1 = y+Math.cos(t1)*orRx*sr+Math.sin(t1)*orRy*cr;
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
      ctx.strokeStyle = `rgba(${orc.r},${orc.g},${orc.b},${alpha.toFixed(2)})`;
      ctx.lineWidth = lw; ctx.stroke();
    }
  }
  function outerRingSpark(orRx, orRy, rot, tSpd) {
    const cr = Math.cos(rot), sr = Math.sin(rot);
    const sT = animTime*tSpd + bp;
    const sx = x+Math.cos(sT)*orRx*cr-Math.sin(sT)*orRy*sr;
    const sy = y+Math.cos(sT)*orRx*sr+Math.sin(sT)*orRy*cr;
    const sg = ctx.createRadialGradient(sx,sy,0,sx,sy,3.5);
    sg.addColorStop(0,`rgba(${orc.r},${orc.g},${orc.b},.75)`);
    sg.addColorStop(1,`rgba(${orc.r},${orc.g},${orc.b},0)`);
    ctx.beginPath(); ctx.arc(sx,sy,3.5,0,Math.PI*2); ctx.fillStyle=sg; ctx.fill();
    ctx.beginPath(); ctx.arc(sx,sy,1.1,0,Math.PI*2);
    ctx.fillStyle=`rgba(${orc.r},${orc.g},${orc.b},.90)`; ctx.fill();
  }

  // 2 equatorial (normal + highspeed)
  ringLines(r+6,  r+6,  0, .60*visSpeed, .11, .50*visIntensity); outerRingSpark(r+6,  r+6,  0, .60*visSpeed);
  ringLines(r+14, r+14, 0, 3.6*visSpeed, .07, .38*visIntensity); outerRingSpark(r+14, r+14, 0, 3.6*visSpeed);

  // 4 longitudinal ring lines (2 normal, 2 highspeed)
  const LON = [
    [r*.18, r*1.40, 0,           .55*visSpeed, .10, .44*visIntensity],
    [r*.18, r*1.40, Math.PI/2.8, 3.8*visSpeed, .08, .40*visIntensity],
    [r*.18, r*1.40, Math.PI/1.7, 3.5*visSpeed, .09, .42*visIntensity],
  ];
  LON.forEach(a => ringLines(...a));

  ctx.restore(); // end outside-clip

  // Longitudinal sparks — no clip, travel fully over text
  LON.forEach(([orRx, orRy, rot, tSpd]) => {
    const cr = Math.cos(rot), sr = Math.sin(rot);
    const sT = animTime*tSpd + bp;
    const sx = x+Math.cos(sT)*orRx*cr-Math.sin(sT)*orRy*sr;
    const sy = y+Math.cos(sT)*orRx*sr+Math.sin(sT)*orRy*cr;
    const sg = ctx.createRadialGradient(sx,sy,0,sx,sy,3.2);
    sg.addColorStop(0,`rgba(${orc.r},${orc.g},${orc.b},.78)`);
    sg.addColorStop(1,`rgba(${orc.r},${orc.g},${orc.b},0)`);
    ctx.beginPath(); ctx.arc(sx,sy,3.2,0,Math.PI*2); ctx.fillStyle=sg; ctx.fill();
    ctx.beginPath(); ctx.arc(sx,sy,1.0,0,Math.PI*2);
    ctx.fillStyle=`rgba(${orc.r},${orc.g},${orc.b},.92)`; ctx.fill();
  });

  // 7. Rim light
  const rim = ctx.createRadialGradient(x,y,r*.76,x,y,r);
  rim.addColorStop(0,'rgba(0,0,0,0)');
  rim.addColorStop(1, lightBg
    ? `rgba(${Math.max(0,rc.r-60)},${Math.max(0,rc.g-60)},${Math.max(0,rc.b-60)},.16)`
    : `rgba(${Math.min(255,rc.r+50)},${Math.min(255,rc.g+60)},${Math.min(255,rc.b+70)},.20)`);
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=rim; ctx.fill();

  // 8. Gold ring for urgent in beige
  if (lightBg && b.data.type === 'urgent') {
    ctx.beginPath(); ctx.arc(x,y,r+2,0,Math.PI*2);
    ctx.strokeStyle='rgba(200,168,80,.60)'; ctx.lineWidth=1.5; ctx.stroke();
  }

  // 9. Border
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.strokeStyle = selected
    ? `rgba(${lrc.r},${lrc.g},${lrc.b},0.88)`
    : `rgba(${lrc.r},${lrc.g},${lrc.b},0.38)`;
  ctx.lineWidth = selected ? 2 : 1; ctx.stroke();

  // 10. Selection ring
  if (selected) {
    ctx.beginPath(); ctx.arc(x, y, r+12, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(${lrc.r},${lrc.g},${lrc.b},0.22)`;
    ctx.lineWidth = 1; ctx.setLineDash([4,6]); ctx.stroke(); ctx.setLineDash([]);
  }

  // 11. Text — smile arc parabola
  const lines = b.data.text.split('\n');
  const fs    = Math.max(9, r * 0.24);
  ctx.font = `600 ${fs}px Syne, sans-serif`;
  ctx.fillStyle = lightBg ? 'rgba(255,255,255,.82)' : Th.ballText;
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  const lh = fs * 1.28;
  lines.forEach((line, li) => {
    ctx.fillText(line, x, y + (li - (lines.length-1)/2) * lh);
  });

  // 12. Node dot
  ctx.beginPath(); ctx.arc(x+r*0.63, y-r*0.63, 3.2, 0, Math.PI*2);
  ctx.fillStyle = `rgba(${lrc.r},${lrc.g},${lrc.b},0.72)`; ctx.fill();
  ctx.beginPath(); ctx.arc(x+r*0.63, y-r*0.63, 5.2, 0, Math.PI*2);
  ctx.strokeStyle = `rgba(${lrc.r},${lrc.g},${lrc.b},0.25)`;
  ctx.lineWidth = 1; ctx.stroke();
}

// ─── DRAW FRAME ───────────────────────────────────────────────────────────────
function drawFrame() {
  requestAnimationFrame(drawFrame);
  const Th = getT();

  animTime += 0.016; // ~60fps clock for speed-line phase

  // Background
  ctx.fillStyle = Th.bg;
  ctx.fillRect(0, 0, W, H);

  // Orbital ellipse grid (sphere projection, no fill artifacts)
  const cx = W * 0.5, cy = H * 0.44;
  const orbitBase = theme === 'dark' ? 0.022 : 0.06;
  const orbitA    = Math.min(1, orbitBase * visBgDark).toFixed(3);
  const orbitCol  = theme === 'dark'
    ? `rgba(255,255,255,${orbitA})`
    : `rgba(8,5,3,${orbitA})`;
  ctx.strokeStyle = orbitCol; ctx.lineWidth = 1;
  [0.17, 0.27, 0.37, 0.47, 0.57].forEach(f => {
    ctx.beginPath();
    ctx.ellipse(cx, cy, W * f, H * f * 0.55, 0, 0, Math.PI*2);
    ctx.stroke();
  });

  // Floor line
  ctx.beginPath(); ctx.moveTo(0, H - 1); ctx.lineTo(W, H - 1);
  ctx.strokeStyle = Th.floor; ctx.lineWidth = 1.5; ctx.stroke();

  // Subtle floor glow
  const fg = ctx.createLinearGradient(0, H - 24, 0, H);
  const rc = theme === 'dark' ? 'rgba(255,255,255,0.04)' : 'rgba(100,78,55,0.07)';
  fg.addColorStop(0, 'rgba(0,0,0,0)'); fg.addColorStop(1, rc);
  ctx.fillStyle = fg; ctx.fillRect(0, H - 24, W, 24);

  // Drag zone fill (gradient toward edges)
  const db = getDragBall();
  if (db && db.visible) {
    const bx = db.body.position.x;
    const Tz = Th.zone;

    const lAlpha = Math.max(0, Math.min(1, 1 - bx / ZONE_W));
    if (lAlpha > 0) {
      const lg = ctx.createLinearGradient(0, 0, ZONE_W, 0);
      lg.addColorStop(0, Tz.fill + (0.14 * lAlpha).toFixed(2) + ')');
      lg.addColorStop(1, Tz.fill + '0)');
      ctx.fillStyle = lg; ctx.fillRect(0, 0, ZONE_W, H);
    }

    const rAlpha = Math.max(0, Math.min(1, (bx - (W - ZONE_W)) / ZONE_W));
    if (rAlpha > 0) {
      const rg = ctx.createLinearGradient(W, 0, W - ZONE_W, 0);
      rg.addColorStop(0, Tz.fill + (0.14 * rAlpha).toFixed(2) + ')');
      rg.addColorStop(1, Tz.fill + '0)');
      ctx.fillStyle = rg; ctx.fillRect(W - ZONE_W, 0, ZONE_W, H);
    }
  }

  // Balls
  const vis = balls.filter(b => b.visible);
  vis.forEach(b => {
    const i = balls.indexOf(b);
    drawBall(b, hoveredIdx === i, selectedIdx === i);
  });

  // Counter
  ctx.font         = '400 11px Syne Mono, monospace';
  ctx.fillStyle    = Th.counterText;
  ctx.textAlign    = 'left';
  ctx.textBaseline = 'top';
  const shown = vis.length, total = balls.length;
  ctx.fillText(activeFilter === 'all' ? `${total} offen` : `${shown} / ${total} offen`, 36, 108);
}

// ─── RESIZE ───────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  W = window.innerWidth; H = window.innerHeight - 76;
  canvas.width = W; canvas.height = H;
  walls.forEach(w => Composite.remove(world, w));
  walls = buildWalls();
  Composite.add(world, walls);
});

// ─── INIT ────────────────────────────────────────────────────────────────────
rebuildCatBar();
buildSetsBar();
buildPaletteRow();
drawFrame();
INITIAL.forEach((t, i) => setTimeout(() => spawnBall({ ...t, id: i + 1 }), i * 100));
</script>
</body>
</html>
